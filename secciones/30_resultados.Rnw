\chapter{Resultados}

\section{Modelo Teórico}

\ti{Costo total en USD por año debido a fallas}

\begin{equation}
   \bm{C = \frac{LQPT}{s}}
   \label{costo1}
\end{equation}

Donde:

 \begin{itemize}[itemsep=1ex]
 
  \item \textbf{C:} Costo total de energía eléctrica en USD por año por todos los sitios de
  Tx.
  \item L: Costo por evento en quetzales.
  \item Q: Población de sitios Tx.
  \item P: Probabilidad de que se den 150 fallas en 1 año.
  \item T: Cantidad de cuatrimestres que tiene un año
  \item s: Tipo de cambio para convertir a dólares el resultado

 \end{itemize}


\ti{Costo por evento}

\begin{equation}
   \bm{L = m\Phi}
   \label{costo2}
\end{equation}

Donde:

 \begin{itemize}[itemsep=1ex]
  \item L: Costo por evento en quetzales.
  \item m: Costo del kilowatt por hora
  \item $\Phi$: Cantidad de kilowatts adicionales durante la falla.

 \end{itemize}

\begin{equation}
   \bm{\Phi = \Delta Vt}
   \label{costo3}
\end{equation}

Donde:

 \begin{itemize}[itemsep=1ex]
  \item $\Phi$: Cantidad de kilowatts adicionales durante la falla.
  \item $\Delta$: Diferencia en amperios entre el modo de operación normal y el modo
  de fallo.
  \item V: Voltaje nominal constante.
  \item t: Duración del evento en horas.

 \end{itemize}
 
 \begin{equation}
   \bm{\Delta = f - o}
   \label{costo4}
\end{equation}

Donde:

 \begin{itemize}[itemsep=1ex]
  \item $\Delta$: Diferencia en amperios entre el modo de operación normal y el modo.
  \item f: Distribución de la corriente en modo de falla.
  \item o: Distribución de la corriente en modo de operación normal.

 \end{itemize}
 
 
\section{Análisis Exploratorio}

<<>>=
est_eventos <- eventos |> 
 select(where(is.numeric)) |> 
 resumir()

est_sitios <- sitios |> 
 select(where(is.numeric)) |> 
 resumir()
@

<<>>=
est_totales <- est_eventos |>
 bind_rows(est_sitios)
@

<<>>=
est_totales |> tabla("Resumen Estadístico tabla de Eventos")
@

<<>>=
eventos_n <- eventos %>% select(where(is.numeric))
sitios_n <- sitios %>% select(where(is.numeric))
pal    <- palette_OkabeIto[1:ncol(eventos_n)]
ndv    <- names(eventos_n)
@

\begin{figure}[H]
<<fig.width=7, fig.asp=1>>=
c(p1, p2, p3) %<-% map2(.x = ndv, .y = pal, ~ estimar_densidad(df = eventos, d = .x, color = .y))
p4 <- estimar_densidad(df = sitios, d = "costo_kwh", color = palette_OkabeIto[7])
p1 + p2 + p3 + p4 + 
 plot_annotation(title    = "Análisis de Distribución", 
                 subtitle = "Estimación de densidad no paramétrica")
@
\caption{Distribuciones}
   \label{fig:dis1}
\end{figure}

\section{Análisis Confirmatorio}

\subsection{Bondad de Ajuste}

Con base a \citep[pag. ~2]{delignette-muller_fitdistrplus_2015}

\begin{quote}
"Antes de ajustar una o más distribuciones a un conjunto de datos, generalmente es necesario
elegir buenos candidatos entre un conjunto predefinido de distribuciones. Esta elección puede
estar guiada por el conocimiento de los procesos estocásticos que rigen la variable modelada,
o, en ausencia de conocimiento sobre el proceso subyacente, por la observación de su
distribución empírica.[...]"
\end{quote}

<<>>=
tipodis <- c("norm", "lnorm", "gamma")
@

En el apéndice \ref{appendix:bondad} podemos ver los resultados de todas las pruebas
realizadas a cada una de las variables de dataset.  El código de la implementación de estas
pruebas se encuentra en el apéndice
% \ref{appendix:allcode}
para su referencia. 

<<>>=
eve_gof <- validar_gof(df = eventos_n, tipodis = tipodis)
sit_gof <- validar_gof(df = sitios_n, tipodis = tipodis)
total_gof <- bind_rows(eve_gof, sit_gof)
puntuacion_gof <- total_gof |> scoring_gof()
@

<<bondad>>=
puntuacion_gof |> tabla("Distribución más probable con base a scoring")
@

Aunque en la gráfica \ref{fig:dis1} y en la tabla \ref{tab:bondad} la distribución del
tiempo aparenta seguir una distribución log-normal, en la práctica sabemos que esto no es
así. El tiempo se distribuye de una forma diferente.  Para efectos prácticos, diremos que
la duración de la falla tiene una distribución equiprobable que puede ir desde 1 hora hasta
36 horas.

De igual forma, sabemos que la distribución de la corriente es gaussiana, por lo que
cambiaremos esto.

\section{Análisis de las fallas}

<<>>=
por_sitio |> tabla("Cantidad de fallas por cada sitio en periodo de evaluación (4 meses")
@

<<>>=
frecuencia_eventos |> tabla("Distribución de probabilidades por sitio")
@


\section{Simulación}

Crearemos las distribuciones de entrada con base a los resultados obtenidos en el análisis
exploratorio y en las pruebas de bondad de ajuste de la tabla \ref{tab:bondad}. 

Validemos que las distribuciones creadas con los números aleatorios se corresponden
visualmente con lo esperado.

<<>>=
set.seed(2021)
nreps <- 1e5
@

<<>>=
reparametrizar_rlnorm <- function(x) {
 m <- mean(x)
 s <- sd(x)
 location <- log(m^2 / sqrt(s^2 + m^2))
 shape <- sqrt(log(1 + (s^2 / m^2)))
 list(meanlog = location, sdlog = shape)
}
@

<<>>=
media_costo <- mean(sitios$costo_kwh)
desvi_costo <- sd(sitios$costo_kwh)
media_opera <- mean(eventos$operacion)
desvi_opera <- sd(eventos$operacion)
desvi_falla <- sd(eventos$falla)
media_falla <- mean(eventos$falla)
minimo_operacion <- min(eventos$operacion)
maximo_operacion <- max(eventos$operacion)
minimo_falla <- min(eventos$falla)
maximo_falla <- max(eventos$falla)
@

<<>>=
costo_kwh <- rnorm2(n = nreps, mean = media_costo, sd = desvi_costo)
operacion <- rlnorm2(n = nreps, mean = media_opera, sd = desvi_opera, 
                     min = minimo_operacion, max = maximo_falla)
falla     <- rlnorm2(n = nreps, mean = media_falla, sd = desvi_falla, 
                     min = minimo_falla, max = maximo_falla)
duracion  <- runif(n  = nreps, min = min(eventos$duracion), max = max(eventos$duracion))
@

<<>>=
costo_kwh <- rnorm2(n = nreps, mean = media_costo, sd = desvi_costo)
operacion <- rlnormTrunc(n = nreps, meanlog = media_opera, sdlog = desvi_opera, min = minimo_operacion, max = maximo_falla)
falla     <- rlnormTrunc(n = nreps, meanlog = media_falla, sdlog = desvi_falla, min = minimo_falla, max = maximo_falla)
duracion  <- runif(n  = nreps, min = min(eventos$duracion), max = max(eventos$duracion))
@



<<>>=
# dist <- eventos_n |>
#  select(-duracion) |>
#  map_dfr(~ reparametrizar_rlnorm(.x), .id = "var") |>
#  mutate(sdlog = replace(sdlog, var == "duracion_hrs", 0.67)) |>
#  select(-var) |>
#  pmap(rlnorm, n = nreps) |>
#  append(list(dis_duracion, dis_costo)) |>
#  set_names(nom_vars) |>
#  bind_rows(.id = "var")
@



% <<>>=
% media_costo <- mean(sitios$costo_kwh)
% desvi_costo <- sd(sitios$costo_kwh)
% media_opera <- mean(eventos$operacion)
% desvi_opera <- sd(eventos$operacion)
% desvi_falla <- sd(eventos$falla)
% media_falla <- mean(eventos$falla)
% @
% 
% 
% <<>>=
% nom_vars <- c(names(eventos_n), names(sitios_n))
% @
% 
% <<>>=
% costo_kwh <- rnorm2(n = nreps, mean = media_costo, sd = desvi_costo) |> as.numeric()
% operacion <- rnorm2(n = nreps, mean = media_opera, sd = desvi_opera) |> as.numeric()
% falla     <- rnorm2(n = nreps, mean = media_falla, sd = desvi_falla) |> as.numeric()
% duracion  <- runif(n  = nreps, min = 1, max = 36)
% @
 
<<>>=
dist <- tibble(operacion, falla, duracion, costo_kwh)
@
 
<<>>=

@


<<>>=
dist |> 
 slice(1:10) |> 
 tabla("Distribución de valores creadas con números aleatorios")
@

Validemos visualmente que nuestras distribuciones están correctas

<<fig.width=7, fig.asp=1>>=
map2(.x = names(dist), 
     .y = c(pal, palette_OkabeIto[7]), ~ estimar_densidad(df = dist, d = .x, color = .y)) |> 
 reduce(.f = `+`) + 
 plot_layout(ncol = 2) +
 plot_annotation(title    = "Distribución", 
                 subtitle = "Estimación de densidad no paramétrica") 
@

<<>>=
valor_esperado_fallas <- frecuencia_eventos |>
  summarise(esperanza_fallas  = round(sum(fallas * prob_falla))) |> 
  pull(esperanza_fallas)
@

<<>>=
poblacion_sitios_tx <- 150
fallas_cuatrimestre <- sum(frecuencia_eventos$fallas)
cuatrimestres <- 3
lambda <- fallas_cuatrimestre * 3
prob_falla <- ppois(q = poblacion_sitios_tx, lambda, lower.tail = F)
tipo_cambio <- 7.78
@

<<>>=
simulacion <- dist |> 
 mutate(
  voltaje = 120,
  amp_adi = falla - operacion,
  kwh_adi = ((amp_adi * voltaje * duracion) / 1e3),
  costeve = costo_kwh * kwh_adi,
  costopr = valor_esperado_fallas * costeve,
  costo_t = ((costopr * poblacion_sitios_tx * cuatrimestres) / tipo_cambio)
)
@

<<>>=
simulacion <- dist |> 
 mutate(
  voltaje = 120,
  amp_adi = falla - operacion,
  kwh_adi = ((amp_adi * voltaje * duracion) / 1e3),
  costeve = costo_kwh * kwh_adi,
  # costopr = valor_esperado_fallas * costeve,
  costo_t = ((costeve * poblacion_sitios_tx * prob_falla * cuatrimestres) / tipo_cambio)
)
@



<<>>=
simulacion |>
 mutate(across(where(is.numeric), round, 2)) |> 
 slice_sample(n = 15) |> 
 tabla("Resultados Simulación")
@

<<>>=
dol <- dollar_format(accuracy = 0.1)
brk <- hist(simulacion$costo_t, plot = F)$breaks
med <- mean(simulacion$costo_t)
@

<<>>=
simulacion |> 
 ggplot(aes(x = costo_t, y = ..density..)) +
 geom_histogram(fill = "#56B4E9", size = .2, breaks = brk, color = "black") +
 geom_density(size = 1) +
 geom_vline(xintercept = med, color = "black", linetype = "dashed") +
 scale_x_continuous(name = "Utilidades en miles de dólares [K]", labels = dol, breaks = brk) +
 labs(title = "Distribución de las utilidades") + furia
@


<<>>=
mean(simulacion$costo_t)
@

<<>>=
nf <- rnorm(n = nreps, mean = 117.33, sd = 47.4)
lnf <- exp(nf)
hist(lnf)
@

<<>>=
g <- rlnormTrunc(n = nreps, meanlog = 102.7, sdlog = 43.71, min = 54.94, max = 234)
g <- rlnormTruncAlt(n = nreps, mean = 102, cv = 0.4256699, min = 63, max = 256)
h <- rlnorm2(n = nreps, mean = 102.7, sd = 43.71, min = 54.94, max = 234.1)
@

<<>>=
hist(g)
@


 