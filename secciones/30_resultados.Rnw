\chapter{Resultados}

\section{Análisis Exploratorio}

 

<<>>=
eventos_n <- eventos %>% select(where(is.numeric))
sitios_n <- sitios %>% select(where(is.numeric))
pal    <- palette_OkabeIto[1:ncol(eventos_n)]
ndv    <- names(eventos_n)
@

\begin{figure}[H]
<<fig.width=7, fig.asp=1>>=
c(p1, p2, p3) %<-% map2(.x = ndv, .y = pal, ~ estimar_densidad(df = eventos, d = .x, color = .y))
p4 <- estimar_densidad(df = sitios, d = "costo_kwh", color = palette_OkabeIto[7])
p1 + p2 + p3 + p4 + 
 plot_annotation(title    = "Análisis de Distribución", 
                 subtitle = "Estimación de densidad no paramétrica")
@
\caption{Distribuciones}
   \label{fig:dis1}
\end{figure}

<<>>=
est_eventos <- eventos |> 
 select(where(is.numeric)) |> 
 resumir()

est_sitios <- sitios |> 
 select(where(is.numeric)) |> 
 resumir()
@

<<>>=
est_totales <- est_eventos |>
 bind_rows(est_sitios)
@

<<resop>>=
est_totales |> tabla("Resumen Estadístico tabla de Eventos")
@

En la tabla \ref{tab:resop} vemos que la diferencia entre la cantidad de amperios máximos que
se puede alcanzar en modo de falla en de 22 en comparación con el modo normal. Se observa
que en modo de falla la media se incrementa unos 14 amperios. 

\section{Análisis Confirmatorio}

\subsection{Bondad de Ajuste}

Con base a \citep[pag. ~2]{delignette-muller_fitdistrplus_2015}

\begin{quote}
"Antes de ajustar una o más distribuciones a un conjunto de datos, generalmente es necesario
elegir buenos candidatos entre un conjunto predefinido de distribuciones. Esta elección puede
estar guiada por el conocimiento de los procesos estocásticos que rigen la variable modelada,
o, en ausencia de conocimiento sobre el proceso subyacente, por la observación de su
distribución empírica.[...]"
\end{quote}

<<>>=
tipodis <- c("norm", "lnorm", "gamma")
@

En el apéndice \ref{appendix:bondad} podemos ver los resultados de todas las pruebas
realizadas a cada una de las variables de dataset.  El código de la implementación de estas
pruebas se encuentra en el apéndice
% \ref{appendix:allcode}
para su referencia. 

<<>>=
eve_gof <- validar_gof(df = eventos_n, tipodis = tipodis)
sit_gof <- validar_gof(df = sitios_n, tipodis = tipodis)
total_gof <- bind_rows(eve_gof, sit_gof)
puntuacion_gof <- total_gof |> scoring_gof()
@

<<bondad>>=
puntuacion_gof |> tabla("Distribución más probable con base a scoring")
@

Aunque en la gráfica \ref{fig:dis1} y en la tabla \ref{tab:bondad} la distribución del
tiempo aparenta seguir una distribución log-normal, en la práctica sabemos que esto no es
así. El tiempo se distribuye de una forma diferente.  Para efectos prácticos, diremos que
la duración de la falla tiene una distribución equiprobable que estará determinada por
los parámetros de \texttt{min} y \texttt{max} de la muestra.

\section{Frecuencia de las fallas}

<<fallas>>=
por_sitio |> 
 rowid_to_column(var = "item") |> 
 tabla("Cantidad de fallas por cada sitio en periodo de evaluación (4 meses")
@

En la tabla \ref{tab:fallas} vemos que en los cuatro meses de evaluación fallaron 17 sitios
distintos del total de 30, es decir un 56\%.  Algunos de ellos llegaron a tener en este
periodo hasta 11 fallas. El total de fallas registradas en el periodo de evaluación fue de
68.

<<frecuencia>>=
frecuencia_eventos |> tabla("Distribución de probabilidades por sitio")
@

En la tabla \ref{tab:frecuencia} se ha unido la tabla de sitios con la tabla de eventos para
poder obtener las frecuencias relativas.  Esto es útil para poder calcular la
\textbf{esperanza matemática}. 

\section{Simulación}

Crearemos las distribuciones de entrada con base a los resultados obtenidos en el análisis
exploratorio y en las pruebas de bondad de ajuste de la tabla \ref{tab:bondad}. 

Validemos que las distribuciones creadas con los números aleatorios se corresponden
visualmente con lo esperado.

<<>>=
set.seed(2021)
nreps <- 5e3
@

<<>>=
media_costo <- mean(sitios$costo_kwh)
desvi_costo <- sd(sitios$costo_kwh)
min_duracio <- min(eventos$duracion)
max_duracio <- max(eventos$duracion)
@

<<>>=
costo_kwh <- rnorm2(n = nreps, mean = media_costo, sd = desvi_costo)
duracion  <- runif(n  = nreps, min = min_duracio, max = max_duracio)
@

<<>>=
distribuciones <-  eventos_n |> 
 select(-duracion) |> 
 parametros_lognormal() |> 
 select(-var) |> 
 pmap(rlnormTrunc, n = nreps) |> 
 append(list(costo_kwh, duracion)) |> 
 set_names(c("operacion", "falla", "costo_kwh", "duracion")) |> 
 bind_rows(.id = "var")
@


<<>>=
distribuciones |> 
 slice(1:5) |> 
 tabla("Vectores creados con números aleatorios a partir de la distribución de la muestra")
@

Validemos visualmente que nuestras distribuciones generadas con números aleatorios sigan
las mismas distribuciones de la muestra (datos históricos)

\begin{figure}[H]
<<fig.width=7, fig.asp=0.7>>=
map2(.x = names(distribuciones), 
     .y = c(pal, palette_OkabeIto[7]), ~ estimar_densidad(df = distribuciones, d = .x, color = .y)) |> 
 reduce(.f = `+`) + 
 plot_layout(ncol = 2) +
 plot_annotation(title    = "Distribuciones", 
                 subtitle = "Estimación de densidad no paramétrica") 
@
\caption{Distribuciones generadas con números aleatorios}
   \label{fig:disrandom}
\end{figure}



En una tabla podemos comparar los parámetros de los valores de la muestra contra los de
los que fueron generados de forma aleatoria para evaluar que tan diferentes son.

<<comparacion>>=
resumir(eventos_n) |> 
 bind_rows(resumir(sitios[3])) |> 
 mutate(set = "original") |> 
 bind_rows(resumir(distribuciones) |> 
 mutate(set = "random")) |> 
 relocate(set, .before = 1) |> 
 tabla("Comparación valores variables originales vs distribuciones")
@

En la tabla \ref{tab:comparacion} vemos que las variables que siguen una distribución
\emph{log-normal} (\va{operación} y \va{falla}) tiene una variación en la media y la
desviación estándar, pero los valores máximos y mínimos se mantienen iguales.

\subsection{Configurar simulación}

 \begin{itemize}[itemsep=1ex]
  \item \textbf{Población de sitios Tx (Q):} 150
  \item \textbf{Fallas cuatrimestrales:} En la tabla \ref{tab:frecuencia} podemos ver que en
  cuatro meses de evaluación, la cantidad de fallas totales fue de \textbf{68}.
  \item \textbf{Cuatrimestres en un año:} Un año tiene 3 cuatrimestres.
  \item \textbf{Lambda:} Tasa de fallas en un año sera de 68 fallas por la cantidad de
  cuatrimestres, es decir, que en un año se espera que se den 204 fallas.
  \item \textbf{Probabilidad de fallas (P):} Debido a que la cantidad de fallas que se pueden
  presentar en un año sigue una distribución de Poisson, calcularemos de manera
  \textbf{conservadora}, la posibilidad de que se den 150 fallas, es decir, al menos 1 falla
  en toda la población de sitios Tx. 
  \item \textbf{Tipo de cambio:} 7.78
 \end{itemize}

<<>>=
poblacion_sitios_tx <- 150
fallas_cuatrimestre <- sum(frecuencia_eventos$fallas)
cuatrimestres <- 3
lambda <- fallas_cuatrimestre * 3
prob_falla <- ppois(q = poblacion_sitios_tx, lambda, lower.tail = F)
tipo_cambio <- 7.78
@


<<>>=
simulacion <- distribuciones |> 
 mutate(
  voltaje = 120,
  amp_adi = falla - operacion,
  kwh_adi = ((amp_adi * voltaje * duracion) / 1e3),
  costeve = costo_kwh * kwh_adi,
  costo_t = ((costeve * poblacion_sitios_tx * prob_falla * cuatrimestres) / tipo_cambio)
)
@

\subsection{Resultado Simulación}

Aplicando el modelo matemático de la sección \nameref{sec:modeloteorico} obtenemos con
100,000 repeticiones:

<<simulacion>>=
simulacion |>
 mutate(across(where(is.numeric), round, 2)) |> 
 slice_sample(n = 10) |> 
 tabla("Muestra aleatoria de los resultados de la simulación")
@

En la tabla \ref{tab:simulacion} vemos los resultados de la simulación con base al modelo
matemático establecido.

<<>>=
sim <- simulacion |>
 mutate(costo_t = costo_t/1e3)
brk <- hist(sim$costo_t, plot = F)$breaks
med <- mean(sim$costo_t)
@

\begin{figure}[H]
<<resultado, fig.width=7>>=
sim |> 
 ggplot(aes(costo_t)) +
 geom_bar(width = 0.98, fill = "#56B4E9") +
 scale_x_binned(breaks = brk, labels = dol, 
                name = "Costo en Miles de dólares [K]") +
 geom_vline(xintercept = med, linetype = "dashed", color = "black", alpha = .3) +
 scale_y_continuous(expand = c(0, 0)) + furia
@
\caption{Distribución de los costos en Miles de USD que podría haber en un año de operación si no se toman acciones}
   \label{fig:res1}
\end{figure}

\section{Análisis Probabilístico}

<<>>=
resumir(sim$costo_t) |> tabla("Resumen de la variable Costos totales")
@

<<>>=
ct <- resumir(sim$costo_t) |> pull(mean) |> round()
costx <- sim$costo_t
@

En la tabla vemos que el costo promedio es de \Sexpr{ct} mil dólares

<<>>=
lillie.test(costx)
@


<<>>=
sim %>% 
	imap_dfr(~ probar_normalidad(.x) %>%
				mutate(var = .y)) %>% 
	pivot_wider(names_from = "var", values_from = "p_value") %>% 
	mutate(across(where(is.numeric), rd, 2)) %>% 
	tabla(cap = "Pruebas no paramétricas de normalidad")
@


